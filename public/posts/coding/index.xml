<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coding on J. Marcus Hughes</title>
    <link>https://jmbhughes.github.io/posts/coding/</link>
    <description>Recent content in Coding on J. Marcus Hughes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 06 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://jmbhughes.github.io/posts/coding/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mood tracking: first plots</title>
      <link>https://jmbhughes.github.io/posts/coding/mood-tracking/</link>
      <pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://jmbhughes.github.io/posts/coding/mood-tracking/</guid>
      <description>For some time now, I&amp;rsquo;ve been using the app Daylio to track my mood. It allows me to rate my mood on a 5 point scale: awful, bad, meh, good, and rad. I can also put pictures, notes, or log what activities are related to that mood at the same time. It&amp;rsquo;s quite a nifty little app.
I just decided to download the data and start examining it more critically. I hope to build a small set of tools to automatically process all the data and interpret conclusions.</description>
    </item>
    
    <item>
      <title>Sliding puzzles: my beginning</title>
      <link>https://jmbhughes.github.io/posts/coding/sliding-puzzle-start/</link>
      <pubDate>Thu, 27 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://jmbhughes.github.io/posts/coding/sliding-puzzle-start/</guid>
      <description>I recently have become interested in sliding puzzles. You can read all about them on Wikipedia. In undergraduate AI, I was ask to implement a solver for the rush-hour game, a version of a sliding puzzle. I forgot all about it until recently when I was preparing an AI lesson to teach for Code Connects, a coding education non-profit. I stumbled upon the 8-puzzle.
Difficulty of AI At first, it seemed pretty simple, and I thought an AI would do easy on it for bigger boards, but I was sorely mistaken.</description>
    </item>
    
    <item>
      <title>Comparison of speed of np.sum in Cython</title>
      <link>https://jmbhughes.github.io/posts/coding/npsum-cython/</link>
      <pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://jmbhughes.github.io/posts/coding/npsum-cython/</guid>
      <description>I was curious how much the overhead of np.sum impacted Cython code. That is, should you write your own sum method that loops or use np.sum? So, I wrote up a little test definition of the two approaches, as shown below:
import numpy as np cimport numpy as np cpdef double sum_np(np.ndarray[double] a): return np.sum(a) cpdef double sum_loop(double[:] a) nogil: cdef size_t i, I cdef double total = 0.0 I = a.</description>
    </item>
    
    <item>
      <title>Truncate to specified number of significant figures</title>
      <link>https://jmbhughes.github.io/posts/coding/truncate-sigfigs/</link>
      <pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://jmbhughes.github.io/posts/coding/truncate-sigfigs/</guid>
      <description>It&amp;rsquo;s a simple request. You have a number, e.g. 1.25, and want to truncate it to say 2 significant figures. You specifically need to truncate instead of rounding, i.e. you need to get 1.2 instead of 1.3. How do you do that quickly in Python? Check out this code snippet:
from math import log10, floor import decimal decimal.getcontext().rounding = decimal.ROUND_DOWN def truncate_sig(x, sig=2): x = float(x) # make sure it&amp;#39;s a float or decimal throws an error if x == 0: # can&amp;#39;t take log10(0) so just return 0 return 0 elif x &amp;lt;= 0: # if it&amp;#39;s negative, determine sigfigs of positive and multiply by -1 return -1 * truncate_sig(np.</description>
    </item>
    
  </channel>
</rss>
